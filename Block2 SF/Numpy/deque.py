DEQUE
Создадим пустой дек (deque). Для этого сначала импортируем эту структуру данных из модуля collections, а затем создадим её пустой экземпляр:
from collections import deque
dq = deque()
print(dq)
# deque([])
У deque есть четыре ключевые функции:
o	append (добавить элемент в конец дека);
o	appendleft (добавить элемент в начало дека);
o	pop (удалить и вернуть элемент из конца дека);
o	popleft (удалить и вернуть элемент из начала дека).
Рассмотрим их на примере.
Начался рабочий день, и в службу поддержки оператора связи стали поступать звонки от клиентов. В какой-то момент свободные операторы закончились и начала образовываться очередь в ожидании. Добавим несколько человек в очередь с помощью append:
clients = deque()
clients.append('Ivanov')
clients.append('Petrov')
clients.append('Smirnov')
clients.append('Tikhonova')
print(clients)
# deque(['Ivanov', 'Petrov', 'Smirnov', 'Tikhonova'])
Объект deque поддерживает индексацию по элементам:
print(clients[2])
# Smirnov
Освободилось два оператора — заберём двоих человек из начала очереди с помощью popleft:
first_client = clients.popleft()
second_client = clients.popleft()
 
print("First client:", first_client)
print("Second client:", second_client)
print(clients)
# First client: Ivanov
# Second client: Petrov
# deque(['Smirnov', 'Tikhonova'])
Как видите, первые элементы исчезли из очереди. Функции pop и popleft возвращают тот элемент, который они удаляют (последний или первый соответственно).
Вдруг появился VIP-клиент. Для него тоже нет свободного оператора, но добавить его нужно в начало очереди с помощью appendleft:
clients.appendleft('Vip-client')
 
print(clients)
# deque(['Vip-client', 'Smirnov', 'Tikhonova'])
VIP-клиент теперь оказался самым первым в очереди.
Последний клиент в очереди устал ждать и отменил вызов. Удалим его с помощью pop:
tired_client = clients.pop()
print(tired_client, "left the queue")
print(clients)
# Tikhonova left the queue
# deque(['Vip-client', 'Smirnov'])
С помощью pop всегда удаляется последний элемент из дэка. Чтобы удалить конкретный элемент по индексу, необходимо воспользоваться встроенной конструкцией del:
clients = deque(['Ivanov', 'Petrov', 'Smirnov', 'Tikhonova'])
print(clients)
# deque(['Ivanov', 'Petrov', 'Smirnov', 'Tikhonova'])
del clients[2]
print(clients)
# deque(['Ivanov', 'Petrov', 'Tikhonova'])
Также в очередь возможно добавить сразу несколько элементов из итерируемого объекта в дек. Для этого используют функции extend (добавить в конец дека) и extendleft (добавить в начало дека).
Создадим очередь из клиентов магазинчика на заправке и добавим в неё сразу всех туристов, приехавших на экскурсионном автобусе, с помощью extend:
# В скобках передаём список при создании deque,
# чтобы сразу добавить все его элементы в очередь
shop = deque([1, 2, 3, 4, 5])
print(shop)
# deque([1, 2, 3, 4, 5])
shop.extend([11, 12, 13, 14, 15, 16, 17])
print(shop)
# deque([1, 2, 3, 4, 5, 11, 12, 13, 14, 15, 16, 17])
Если вдруг у турфирмы имеется договорённость с магазином, что клиенты турфирмы обслуживаются вне очереди, добавим их в начало той же очереди с помощью extendleft:
shop = deque([1, 2, 3, 4, 5])
print(shop)
# deque([1, 2, 3, 4, 5])
shop.extendleft([11, 12, 13, 14, 15, 16, 17])
print(shop)
# deque([17, 16, 15, 14, 13, 12, 11, 1, 2, 3, 4, 5])
Обратите внимание, что «клиенты из автобуса» оказались в очереди не в том порядке, в каком они «выходили из автобуса». То есть добавленные номера не только приписаны перед записанными в очереди номерами, но также порядок добавленных элементов поменялся на обратный. Это связано с тем, что действие функции extendleft аналогично многократному применению функции appendleft, поэтому самый последний клиент из автобуса оказался в итоге первым в очереди.
ОЧЕРЕДЬ С ОГРАНИЧЕННОЙ МАКСИМАЛЬНОЙ ДЛИНОЙ
При создании очереди можно также указать её максимальную длину с помощью параметра maxlen. Сделать это можно как при создании пустой очереди, так и при создании очереди от заданного итерируемого объекта:
limited = deque(maxlen=3)
print(limited)
# deque([], maxlen=3)
 
limited_from_list = deque([1,3,4,5,6,7], maxlen=3)
print(limited_from_list)
# deque([5, 6, 7], maxlen=3)
Обратите внимание, что теперь дополнительно печатается максимальная длина очереди.
Также заметьте, что в очереди с ограниченной длиной сохраняются только последние элементы, а первые исчезают из памяти:
limited.extend([1,2,3])
print(limited)
# deque([1, 2, 3], maxlen=3)
 
print(limited.append(8))
# None
print(limited)
# deque([2, 3, 8], maxlen=3)
При этом, как видно из результата операции limited.append(8), удаляемый элемент не возвращается, а просто исчезает.
from collections import deque
limited = deque(maxlen=3)
limited.extend ([1,2,3,4])
print (limited)
limited.append ([8])
print (limited)
deque([2, 3, 4], maxlen=3)
deque([3, 4, [8]], maxlen=3)
?Для чего может пригодиться такая возможность?
Например, необходимость в таком инструменте возникает, когда за один раз необходимо обрабатывать строго фиксированное число элементов. Особенно это актуально для анализа динамики какого-то значения во времени.
Ниже приведены средние дневные температуры в Москве за июль:
temps = [20.6, 19.4, 19.0, 19.0, 22.1,
        22.5, 22.8, 24.1, 25.6, 27.0,
        27.0, 25.6, 26.8, 27.3, 22.5,
        25.4, 24.4, 23.7, 23.6, 22.6,
        20.4, 17.9, 17.3, 17.3, 18.1,
        20.1, 22.2, 19.8, 21.3, 21.3,
        21.9]
Посчитаем динамику средней температуры с усреднением за каждые последние 7 дней для каждого рассматриваемого дня. Для этого воспользуемся очередью с параметром maxlen=7:
days = deque(maxlen=7)
 
for temp in temps:
    # Добавляем температуру в очередь
    days.append(temp)
    # Если длина очереди оказалась равной максимальной длине очереди (7),
    # печатаем среднюю температуру за последние 7 дней
    if len(days) == days.maxlen:
        print(round(sum(days) / len(days), 2), end='; ')
# Напечатаем пустую строку, чтобы завершить действие параметра
# end. Иначе следующая строка окажется напечатанной на предыдущей
print("")
# Результат:
# 20.77; 21.27; 22.16; 23.3; 24.44; 24.94; 25.56; 26.2; 25.97;
# 25.94; 25.57; 25.1; 24.81; 24.21; 23.23; 22.57; 21.41; 20.4;
# 19.6; 19.1; 19.04; 18.96; 19.44; 20.01; 20.67;
Как видите, для решения этой задачи очень подошла очередь с ограниченной длиной, поскольку нам не приходилось самостоятельно контролировать число элементов. Структура данных сама контролировала все технические детали.
ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ
Вы уже узнали основные функции append, pop и extend (а также их собратьев для аналогичных действий с левого конца дека). Теперь рассмотрим дополнительные функции, которые позволяют совершать действия с очередью.
1reverse позволяет поменять порядок элементов в очереди на обратный:
dq = deque([1,2,3,4,5])
print(dq)
# deque([1, 2, 3, 4, 5])
 
dq.reverse()
print(dq)
# deque([5, 4, 3, 2, 1])
2rotate переносит  заданных элементов из конца очереди в начало:
dq = deque([1,2,3,4,5])
print(dq)
# deque([1, 2, 3, 4, 5])
 
dq.rotate(2)
print(dq)
# deque([4, 5, 1, 2, 3])
Элементы можно переносить и из начала в конец:
dq = deque([1,2,3,4,5])
print(dq)
# deque([1, 2, 3, 4, 5])
 
# Отрицательное значение аргумента переносит
# n элементов из начала в конец
dq.rotate(-2)
print(dq)
# deque([3, 4, 5, 1, 2])
Обратите внимание, что порядок внутри перенесённых элементов остался тем же, каким был изначально. Вспомните, в каком порядке добавляются элементы в начало очереди функцией extend, и сопоставьте с действием rotate.
34Функция index позволяет найти первый индекс искомого элемента, а count позволяет подсчитать, сколько раз элемент встретился в очереди (функции аналогичны одноимённым функциям для списков):
dq = [1,2,4,2,3,1,5,4,4,4,4,4,3]
print(dq.index(4))
# 2
print(dq.count(4))
# 6
Обратите внимание, что при попытке узнать индекс несуществующего элемента возникнет ValueError:
dq = deque([1,2,4,2,3,1,5,4,4,4,4,4,3])
print(dq.index(25))
# ValueError: 25 is not in deque
А вот посчитать несуществующий элемент можно (получится просто 0):
dq = deque([1,2,4,2,3,1,5,4,4,4,4,4,3])
print(dq.count(25))
# 0
5Наконец, функция clear позволяет очистить очередь:
dq = deque([1,2,4,2,3,1,5,4,4,4,4,4,3])
print(dq)
# deque([1, 2, 4, 2, 3, 1, 5, 4, 4, 4, 4, 4, 3])
dq.clear()
print(dq)
# deque([])
